# Algorithms
Реализованы следующие алгоритмы:

## sort
Реализовать один из гибридных алгоритмов, сочетающий быструю сортировку и сортировку вставками следующим образом: в алгоритме быстрой сортировки, участки массива длины меньшей некоторого параметра k сортировать сортировкой вставками, не используя для них рекурсию быстрой сортировки.

Проделать вычислительный эксперимент. Подобрать оптимальное k для сортировки R массивов длины N, элементы которых - случайные целые числа в диапазоне от 0 до M.

Дать возможность пользователю задавать параметры R,N и M.
 Реализовать один из гибридных алгоритмов, сочетающий сортировку слиянием и сортировку вставками следующим образом: в алгоритме сортировки слиянием, участки массива длины меньшей некоторого параметра k сортировать сортировкой вставками, не используя для них рекурсию сортировки слиянием.

Проделать вычислительный эксперимент. Подобрать оптимальное k для сортировки R массивов длины N, элементы которых - случайные целые числа в диапазоне от 0 до M.

Дать возможность пользователю задавать параметры R,N и M.

## search 
Реализовать алгоритмы бинарного и интерполяционного поиска числа x в массиве длины N, элементы которых - случайные целые числа в диапазоне от 0 до M. Вывести число операций сравнения, выполненных алгоритмом для заданных N, M и x.
 
## binary search tree
 Реализовать алгоритмы построения, обхода и балансировки дерева бинарного поиска (BST). На вход алгоритма подается последовательность целых положительных чисел a_1,a_2,...,a_n. Программа должна строить BST, добавляя узлы в порядке последовательности. Реализовать обходы дерева по возрастанию узлов и по убыванию узлов. Реализовать алгоритм нахождения  k-го минимального ключа в дереве; на его основе сбалансировать построенное дерево (ротациями вправо и влево n/2-минимальный элемент помещается в корень, затем данная процедура рекурсивно повторяется для поддеревьев с корнями в дочерних узлах). 

## hashing
 Реализовать алгоритм хеширования методом умножения с разрешением коллизий цепочками переполнения, линейного зондирования и двойным хешированием. В вычислительном эксперименте подобрать свою константу для метода умножения, сравнить ее с константой Кнута по наибольшей длине цепочек коллизий (множества ключей с равным хеш-значением) для P наборов из N случайных ключей от 1 до R, при длине хеш-таблицы M.

## euler 
Граф G задан списками смежностей вершин. Найти компоненты связности графа G. Определить, является ли граф G эйлеровым; если граф G - эйлеров, построить эйлеров цикл. Определить, является ли граф G двудольным; если G - двудольный, найти разбиение на доли.

## shortest path
 В городе есть N перекрестков и M дорог (каждая дорога начинается и заканчивается перекрестком, дороги имеют направление). Известно время проезда каждой дороги (время проезда дорог i->j и j->i может быть различным). Определить перекресток для расположения на нем пожарной станции с условием: пожарная машина должна попасть в наиболее удаленный от станции перекресток за минимальное возможное время (пожарная машина может нарушать требования ПДД и ехать по встречному направлению).  Задачу реализовать 2-мя алгоритмами.

## minimal spanning tree
 Есть N узлов, которые необходимо объединить в сеть. Известна стоимость прокладки  оптоволоконного кабеля между любой парой узлов. Требуется спроектировать связную сеть (сеть, между любыми узлами которой можно передать сигнал) минимальной стоимости.  Задачу реализовать 2-мя алгоритмами.

## maximum matching 
Есть K сотрудников и K задач. Для каждого сотрудника i определены задачи N(i), которые он умеет выполнять. Назначить задачи сотрудникам, так чтобы каждый сотрудник работал только над одной задачей, и все задачи были выполнены. В случае невозможности такого назначения, указать, какого сотрудника необходимо обучить какой задаче для возможности искомого назначения.

## stable matching problem
 В компании есть N сотрудников и M задач для исполнения. У каждого сотрудника x есть список заинтересованности N(x) в работе над задачами, которые он умеет выполнять (в порядке убывания интереса). Для каждой задачи y известен список эффективности сотрудников S(y), умеющих выполнять эту задачу (в порядке убывания эффективности). Над каждой задачей может работать не более одного сотрудника, и каждый сотрудник может работать над не более чем одной задачей.  Провести 2 разных распределения максимального числа задач по сотрудникам в компании в соответствии с принципами:

Сотрудник x мог быть назначен выполнять задачу t, только если все более интересные для него задачи были назначены для выполнения другим, более эффективным для их выполнения сотрудникам, чем x.
Задача t назначена сотруднику x, только если все более эффективные для выполнения задачи t сотрудники, были назначены на другие более интересные для них задачи.

## travelling salesman problem
Решить задачу коммивояжёра методом ветвей и границ (алгоритм Литтла). Найти все наиболее выгодные пути.



